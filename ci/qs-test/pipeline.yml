resources:
- name: repo
  type: git
  check_every: 1m
  icon: github
  source:
    uri: ((repo.url))
    branch: ((repo.branch))
    ignore_paths:
    - ci/
- name: ci-repo
  type: git
  check_every: 1m
  icon: github
  source:
    uri: ((repo.url))
    branch: ((repo.branch))
    paths:
    - ci/
- name: docker-image
  type: registry-image
  icon: docker
  source:
    repository: ((tappc-registry.url))/ci/docker-image
    username: ((tappc-registry.username))
    password: ((tappc-registry.password))
    tag: latest

jobs:
# - name: set-pipeline
#   plan:
#   - get: ci-repo
#     params:
#       submodules: none
#     trigger: true
#   - set_pipeline: self
#     file: ci-repo/ci/images/pipeline.yml
#     var_files:
#     - ci-repo/ci/images/pipeline.vars.yml

- name: test
  plan:
  - in_parallel:
    - get: docker-image
    - get: ci-repo
      params:
        submodules: none
    - get: repo
  - task: get-cloudgate-creds
    image: docker-image
    file: ci-repo/ci/tasks/get-cloudgate-creds/task.yml
    params:
      CLOUDGATE_BASE_URL: https://api.console.cloudgate.vmware.com
      CLOUDGATE_CLIENT_ID: ((ci/cloudgate.clientId))
      CLOUDGATE_CLIENT_SECRET: ((ci/cloudgate.clientSecret))
      CLOUDGATE_MASTER_ACCOUNT_ID: ((ci/cloudgate.masterAccountId))
      CLOUDGATE_ORG_ACCOUNT_ID: ((ci/cloudgate.orgAccountId))
      CLOUDGATE_OU_ID: ((ci/cloudgate.ouId))
      CLOUDGATE_TTL: 43200
  - task: taskcat-test
    image: docker-image
    params:
      NIMBUS_USER: ((ci/nimbus.user))
      NIMBUS_DEPLOY_OPTS: '--cpus=4 --memory=4096'
      DOCKER_HUB_PROXY: ((dockerhub-proxy))
    config:
      platform: linux
      inputs:
      - name: creds
      - name: repo
      caches:
      - path: image-cache
      run:
        path: execute
        args:
        - bash
        - -c
        - |
          set -e
          set -u
          set -o pipefail

          # TODO move to image
          apt-get -y update
          apt-get -y install pigz

          source creds/env.inc.sh

          # TODO: remove
          # docker login "${DOCKER_URL}" -u "${DOCKER_USER}" --password-stdin <<< "${DOCKER_PASS}"

          preheatFromDockerfiles() {
            local dir="${1:-.}"
            local orgImg proxyImg
            local proxy="${DOCKER_HUB_PROXY?}"

            while read orgImg ; do
              if grep -q '/' <<< "$orgImg" ; then
                proxyImg="${proxy}/${orgImg}"
              else
                proxyImg="${proxy}/library/${orgImg}"
              fi

              docker pull "$proxyImg" || {
                echo >&2 "Could not pull '$proxyImg', skipping"
                continue
              }

              docker tag "$proxyImg" "$orgImg" || {
                echo >&2 "Could not retag '$proxyImg' to '$orgImg', skipping"
                continue
              }
            done <<< "$( find "$dir" -type f -iname Dockerfile | xargs -r sed -n 's/^FROM \(.*\)/\1/ip' | sort | uniq )"
          }

          imageCacheSave() {
            local dest="$1"
            local images=()
            local repo tag id

            while read repo tag id
            do
              if [[ "$repo" == '<none>' ]] || [[ "$tag" == '<none>' ]] ; then
                images+=( "$id" )
              else
                images+=( "${repo}:${tag}" )
              fi
            done < <( docker image ls -a --format '{{ .Repository }}\t{{ .Tag }}\t{{ .ID }}' )

            docker save "${images[@]}" | pigz > "$dest"
          }

          imageCacheLoad() {
            local images="$1"

            [[ -e "$images" ]] || {
              echo >&2 "'$images' does not exist, not loading cached layers"
              return
            }

            # docker load can handle gzipped tarballs
            docker load -i "$images"
          }

          main() {
            taskcat package -s functions/source -z functions/packages
          }

          runLogged() {
            local msg="$1" ; shift
            local rc=0

            echo >&2 "## ---- ${msg}"
            "$@" || rc=$?
            echo >&2 "## ----"
            echo >&2

            return $rc
          }

          imageCache="${PWD}/image-cache/images.tar.gz"
          cd repo

          runLogged 'load images from cache' \
            imageCacheLoad "$imageCache" || true
          runLogged 'preheat docker image cache from Dockerfiles' \
            preheatFromDockerfiles . || true

          rc=0
          runLogged 'main task' main || rc=$?

          runLogged 'save images to cache' \
            imageCacheSave "$imageCache" || true

          exit $rc
